# AbyssCurse 插件开发方案（2025-11 更新）

> 本文档用于同步《需求文档》与当前代码实现的真实状态，明确已交付能力、差距以及下一阶段的工作计划。代码路径以 `src/main/java/io/github/kaleidscoper/abysscurse` 为基准。

---

## 1. 背景与目标

- 插件定位：为 Paper 1.21.1 服务器实现“深渊诅咒”体验，核心机制是**在特定区域内累积上升 2m 触发分层惩罚**。
- 当前问题：旧版《开发方案》描述了大量尚未实现的模块（AchievementManager、NarehateManager 等），与 `doc/需求文档.md` 及现有源码严重不符，难以指导研发。
- 本次更新目标：
  1. 描述当前代码可实际交付的功能。
  2. 标注与需求的差异及技术债。
  3. 给出后续迭代的优先事项与建议实现路径。

---

## 2. 当前实现概览

- **插件模式**：`OFF / ABYSS / WORLD` 已实现，存储于 `config.yml`，可通过 `/abysscurse mode ...` 切换（仅保存配置，未广播事件）。
- **Abyss 区域判定**：`RegionManager` 支持切比雪夫距离与豁免区/豁免者判断；但缺少命令接口管理豁免数据。
- **玩家数据**：`PlayerDataManager` 记录安全高度、累计上升时间戳队列、当前诅咒信息，并异步落盘 `plugins/AbyssCurse/players/{uuid}.yml`。
- **诅咒触发**：`AbyssCurseListener` 每秒检测 Y 变化，调用 `CurseManager` 计算分层、动态时长（与诅咒臂成反比），施加药水效果。
- **效果系统**：`EffectManager` 提供按来源的优先级合并，目前诅咒用例全部使用 amplifier=1（与需求数值不符）。
- **视觉/音效**：`VisualManager`（Title+BossBar）、`SoundManager`（远古守卫者音效 & 第三层随机音效）、`FilterManager`（ActionBar 累计上升提示）均已实现；但由于主类初始化顺序错误，`CurseManager` / `LayerEffectManager` 没有拿到实例，造成实际运行中**滤镜、音效、BossBar 全部失效**。
- **调试与命令**：`/abysscurse` 支持 `mode | reload | info | debug`，`DebugManager` 可在 ActionBar 输出模式/坐标/累计上升等调试信息；无任何区域、豁免、诅咒模式或测试用命令。
- **未实现模块**：`decompression-sickness` 模式、右键禁用/静音/聊天限制、寄生效果、生骸/成就系统、API/外部扩展均缺席。

---

## 3. 系统流程（真实行为）

### 3.1 插件启动（`AbyssCursePlugin#onEnable`）
1. 加载配置、模式、区域、玩家数据、效果等管理器。
2. 注册命令与监听器。
3. 安排 5 分钟一次的自动保存任务。
4. 如果开启全局调试则启动 ActionBar 输出来回显状态。
> ⚠️ 当前启动顺序在 `CurseManager` 初始化后才 new `FilterManager/SoundManager/VisualManager`，导致这些依赖未注入，属于急需修复的技术债。

### 3.2 玩家高度监控
- 玩家加入时创建/加载 `PlayerCurseData`，清空累计上升并记录当前高度为安全高度。
- `AbyssCurseListener` 为每个在线玩家开一个 20 tick 定时任务：
  - 若模式为 OFF 或玩家不在 Abyss/处于豁免状态，仅同步 `lastY` 不做统计。
  - 上升时使用 `Math.round(currentY-lastY)` 计算格数，逐格记录时间戳；下降时刷新安全高度。
  - 累计上升队列会自动清理 20 分钟前的记录。
  - 当 `totalRise >= 2` 时触发诅咒，清空累计上升并将当前高度设为新的安全高度。

### 3.3 诅咒生命周期
1. `CurseManager#triggerCurse` 根据安全高度判定层级（共 7 层），计算诅咒臂与持续时长。
2. 调用 `EffectManager` 施加药水效果，并记录 `curseStartTime` / `curseDuration`。
3. 若成功注入 `FilterManager/SoundManager`，应分别展示第一层滤镜/播放第三层随机音效（目前由于注入为 null 未生效）。
4. `CurseManager` 会为玩家启动 1 秒一次的过期检测任务，自动移除效果。第七层会强制击杀；第六层生骸化逻辑尚未实现。

### 3.4 数据持久化与调试
- 玩家离线或定时任务触发时，`PlayerDataManager` 异步保存数据。
- `/abysscurse debug` 可开启个人调试 HUD，全局调试开关写入配置。
- 目前无任何针对豁免区、豁免者的命令；需手动改 `config.yml`。

---

## 4. 模块设计与状态

每个小节按照 **职责 → 现状 → 待办 / 风险** 描述。

### 4.1 ConfigManager (`config/ConfigManager.java`)
- **职责**：加载/保存 YAML 配置；暴露模式、Abyss 区域、诅咒模式、调试开关等。
- **现状**：支持 `mode`、`abyss.center/ radius`、`curse-mode`、`debug.enabled`；默认配置随插件一起打包。`curse-mode` 仅保存字符串，未驱动任何逻辑。
- **待办**：
  - 提供豁免区、豁免者的读写 API（目前由 `RegionManager` 直接操纵 `FileConfiguration`，无校验）。
  - 统一暴露 `abyss` 结构（如世界名、坐标合法性）并在命令层校验。

### 4.2 ModeManager (`mode/ModeManager.java`)
- **职责**：记录当前模式并允许切换。
- **现状**：切换时仅写配置并打印日志，未向其它模块发布事件；`setMode` 内部 TODO 提醒需要通知 Region/Curse。
- **待办**：
  - 切换模式时应刷新 `RegionManager` 缓存、重新评估在线玩家状态、清理现有效果。
  - `mode` 与 `curse-mode` 应在命令层结合，允许一次性配置。

### 4.3 RegionManager (`region/RegionManager.java`)
- **职责**：判断是否在 Abyss、豁免区、豁免者列表，并计算诅咒臂。
- **现状**：
  - 切比雪夫算法按区块维度实现，`WORLD` 模式自动认定主世界为 Abyss。
  - 支持读取/写入 `exemption.zones`、`exemption.players`，但缺少命令入口与数据校验。
- **待办**：
  - 增加命令：添加/删除豁免区、设置玩家豁免者、列出当前配置。
  - 为多世界场景加入世界名，防止坐标跨世界误判。

### 4.4 PlayerDataManager & PlayerCurseData (`data`)
- **职责**：缓存在线玩家状态并异步保存。
- **现状**：使用 `ConcurrentHashMap` 和 `ConcurrentLinkedQueue`，支持自动过期、auto-save、onJoin/onQuit 流程；数据字段已包含 `isNarehate` 与 `narehateType`，但无写入逻辑。
- **待办**：
  - 扩展数据结构以保存豁免者、自定义成就等信息。
  - 针对离线玩家的累计上升记录清理策略需要讨论（目前直接清空）。

### 4.5 CurseManager (`curse/CurseManager.java`)
- **职责**：分层判定、动态时长、效果调度、过期处理。
- **现状**：
  - 七层范围与需求一致，但只覆盖 `abyss-curse` 模式。
  - 诅咒效果触发后会创建一个 1 秒一次的任务监控持续时间。
  - 第六层生骸/第七层击杀逻辑部分实现（仅第七层执行 `setHealth(0)`）。
- **待办 / 风险**：
  - 没有 `decompression-sickness` 分支。
  - 第一层滤镜、第三层音效因未注入管理器而失效。
  - 诅咒结束转生骸、禁止右键/聊天等功能留有 TODO。

### 4.6 EffectManager (`effect/EffectManager.java`)
- **职责**：统一合并药水效果，区分来源优先级。
- **现状**：
  - 诅咒效果完全依赖药水，且 amplifier 均为 1，与需求（如饥饿3、缓慢6）不符。
  - 层级/生骸效果入口已经预留，但层级效果被注释为“已移除”，生骸未实现。
- **待办**：
  - 根据需求调整 amplifier 与效果组合；实现右键禁用、静音等非药水效果需要在监听器中补齐。
  - 为 `EffectSource.LAYER` 恢复 Title/BossBar 以外的效果（若需求确实改为仅视觉，需要在需求文档中加注）。

### 4.7 LayerEffectManager (`effect/LayerEffectManager.java`)
- **职责**：根据玩家当前高度施加层级效果并驱动视觉提示。
- **现状**：
  - 只保留了调用 `visualManager.updateLayerDisplay` 的管道，但由于 VisualManager 未注入，实际无输出。
  - 明确注释“层级增益效果已移除”，与需求文档不符。
- **待办**：
  - 修复初始化顺序；若确实不再提供药水增益，需要在需求文档中同步；否则需要实现对应的成就与限制。

### 4.8 FilterManager (`filter/FilterManager.java`)
- **职责**：在 ActionBar 显示“累计上升高度 1/2”的红色提示；第一层诅咒时强制重度滤镜。
- **现状**：逻辑完整，但 `CurseManager#setFilterManager` 在 `FilterManager` new 之前就被调用，导致 `curseFilterState` 永远不会被触发，只剩下定时任务根据 `PlayerCurseData` 的 getTotalRise() 刷新轻度提示。
- **待办**：修复注入顺序，并确认 ActionBar 与调试 HUD 是否会互相覆盖（可能需要统一输出渠道）。

### 4.9 SoundManager (`sound/SoundManager.java`)
- **职责**：播放远古守卫者音效，第三层循环播放随机怪物/洞穴/TNT 声。
- **现状**：音效库已构建，但同样因为未注入 `CurseManager`，无法触发。
- **待办**：修复依赖注入；补充第五层静音（需求要求“游戏静音”）的实现策略。

### 4.10 VisualManager (`visual/VisualManager.java`)
- **职责**：当玩家进入不同高度层时展示 Title/Subtitle + BossBar。
- **现状**：逻辑完整，支持不同颜色、进度条；但 `LayerEffectManager#setVisualManager` 在 visual 实例创建前调用，导致永远为 null。
- **待办**：重构主类初始化顺序，或提供显式的 `afterInit()` 钩子注入依赖；加入成就触发接口。

### 4.11 DebugManager (`debug/DebugManager.java`)
- **职责**：调试 HUD、全局/个人调试开关、命令输出详细信息。
- **现状**：功能完备，ActionBar 输出模式、坐标、上升值、安全高度、层级、Abyss/豁免状态等；可通过 `debug global on/off` 控制循环任务。
- **待办**：与滤镜/ActionBar 输出统一排队，避免相互覆盖。

### 4.12 CommandHandler (`command/CommandHandler.java`)
- **职责**：处理 `/abysscurse` 命令。
- **现状**：仅有 `mode/reload/info/debug`，且 `mode abyss` 只支持一次设置中心与半径。没有针对豁免、诅咒模式、调试信息拉取、手动触发诅咒的命令。
- **待办**：
  - 补齐 `exemption add/remove/list`、`narehate add/remove`、`curse-mode set`、`simulate` 等子命令。
  - 引入权限粒度控制与国际化文本。

---

## 5. 需求对照表（节选）

| 需求项（摘自《需求文档》） | 当前状态 | 说明 |
| --- | --- | --- |
| 模式管理（off/abyss/world） | ✅ 实现 | `/abysscurse mode` 可切换，缺少通知流程 |
| abyss 区域：中心坐标 + 半径、切比雪夫距离 | ✅ 实现 | 仅支持单个区域；未校验世界名 |
| 豁免区/豁免者配置与命令 | ⚠️ 部分 | 代码支持读写，缺命令入口；不会热加载 |
| 累计上升 2m 阈值、20 分钟过期 | ✅ 实现 | 队列维护，tick 任务每秒执行 |
| ActionBar 显示“累计上升高度 1/2” | ⚠️ 部分 | 正常显示；第一层强制滤镜因注入顺序失效 |
| 诅咒分层效果（药水数值、禁用交互、静音等） | ⚠️ 大量缺失 | 目前仅药水效果，且全部 amplifier=1；无交互限制 |
| 第三层随机音效 & 触发音效 | ⚠️ 未生效 | SoundManager 未注入 |
| 层级 Title/Subtitle、成就树 | ❌ 缺失 | VisualManager 未生效，成就未开发 |
| 诅咒臂动态时长 | ✅ 实现 | `(radius-arm)/radius * 600s`，arm=radius 时 0s |
| decompression-sickness 模式 | ❌ 缺失 | 配置项存在，逻辑未实现 |
| 生骸系统（随机祝福、永久免疫） | ❌ 缺失 | 数据字段存在，无触发/效果 |
| 禁止右键、静音、聊天锁定 | ❌ 缺失 | 需事件监听器实现 |
| 成就树“深渊” | ❌ 缺失 | 未创建自定义进度 |

---

## 6. 下一阶段工作计划（建议优先级）

1. **修复初始化顺序**（P0）
   - 在 `AbyssCursePlugin#onEnable` 中先创建所有管理器，再注入依赖，确保滤镜/音效/视觉生效。
   - 引入简单的 `postInit()` 或使用依赖注入框架，避免未来再出现类似问题。

2. **补齐核心玩法缺口**（P0）
   - 重新实现七层诅咒内容：调整药水放大倍率，实现禁止右键、静音、聊天限制（建议使用 Bukkit 事件监听 + Adventure API）。
   - 完成第三层随机音效、第一层重度滤镜。
   - 实现 `decompression-sickness` 模式开关。

3. **交互命令与配置管理**（P1）
   - 增加 `exemption`、`narehate`、`curse-mode`、`simulate` 等子命令。
   - 切换模式／更新区域后立即刷新在线玩家状态。

4. **视觉与成就**（P1）
   - 修复 Title/BossBar，并根据需求实现成就树触发。
   - 讨论层级增益是否保留，仅视觉或兼容药水需要在需求中确认。

5. **生骸系统**（P2）
   - 第六层诅咒结束后未死亡即转生骸，随机赋予 LUCKY/SAD 效果（EffectSource.NAREHATE）。
   - 为生骸添加命令与持久化开关。

6. **扩展模式与 API**（P3）
   - `decompression-sickness` 模式、对外 API、性能 profiling、Roadmap 阶段 IV 事项。

---

## 7. 技术债与风险

- **依赖注入顺序错误**：导致视觉/音效/滤镜功能完全失效，属于高优先级 Bug。
- **ActionBar 输出冲突**：调试 HUD、滤镜提示共用 ActionBar，需要统一管理以避免互相覆盖。
- **诅咒效果与需求差异**：药水强度、非药水限制、声音/聊天控制均未实现，直接影响玩法体验。
- **命令与配置缺失**：豁免区/豁免者只能手工改配置，不利于运营；模式切换没有立即刷新在线玩家。
- **未实现的系统**：生骸、成就、decompression 模式等占据《需求文档》很大篇幅，需要明确迭代计划。
- **性能风险**：每个玩家持有两个定时任务（高度检测 + 诅咒过期），需要在多人场景下验证是否需要合并任务或降低频率。

---

## 8. 参考文件与路径

- 需求规范：`doc/需求文档.md`
- 代码入口：`src/main/java/io/github/kaleidscoper/abysscurse/AbyssCursePlugin.java`
- 配置模板：`src/main/resources/config.yml`
- 测试记录：`doc/前期测试记录（一至三阶段）.md`

---

> 本文档会随功能交付持续更新，请在合并实现后同步对应章节与《需求文档》，避免再次出现“文档图纸与代码脱节”的情况。
   - 在 CurseManager 中检查

**设计要点**：
- 使用随机数生成器分配类型
- 效果永久持续（定期刷新）
- 聊天栏禁用：监听聊天事件并取消

### 2.8 AchievementManager (成就管理器)

**职责**：
- 管理自定义成就系统
- 触发成就
- 成就进度显示

**功能**：
1. **成就定义**
   - 使用 Paper 的 Advancement API
   - 创建独立的成就树（命名空间：abysscurse）
   - 隐藏成就（hidden: true）
   
2. **成就触发**
   - 进入对应层级时触发
   - 成为生骸时触发
   - 挑战类成就使用特殊音效
   
3. **成就列表和描述文本**
   - 阿比斯之渊（根节点，默认达成；描述文本："故事从这里开始"）
     - 赤笛（描述文本："望向深渊"）
       - 苍笛（描述文本："离开摇篮"）
         - 月笛（描述文本："刻写历史"）
           - 黑笛（描述文本："带回故事"）
             - 白笛（描述文本："成为传说"）
               - 绝界行（描述文本："有去无回"）
                 - 来自深渊（描述文本："回归深渊"）
                 - 奈落之底（描述文本："故事不会从这里结束"）

**设计要点**：
- 使用 JSON 文件定义成就（advancements/）
- 挑战类成就：`"criteria": {"trigger": "minecraft:impossible"}`
- 音效：`ui.toast.challenge_complete`

### 2.9 CommandHandler (命令处理器)

**职责**：
- 处理所有命令
- 权限检查
- 命令参数验证

**功能**：
1. **模式切换命令**
   - `/abysscurse mode <off|abyss|world> [centerX] [centerY] [centerZ] [radius]`
   - 权限：`abysscurse.admin`
   - 参数说明：radius 为 abyss 半径（切比雪夫距离，区块单位）
   
2. **区域管理命令**
   - `/abysscurse abyss set <x> <y> <z> <radius>` - 设置 abyss 区域
   - 参数说明：radius 为 abyss 半径（切比雪夫距离，区块单位）
   - `/abysscurse exemption add <x1> <y1> <z1> <x2> <y2> <z2>` - 添加豁免区
   - `/abysscurse exemption remove <index>` - 删除豁免区
   - `/abysscurse exemption list` - 列出豁免区
   
3. **豁免者管理命令**
   - `/abysscurse narehate add <player>` - 添加豁免者
   - `/abysscurse narehate remove <player>` - 移除豁免者
   - `/abysscurse narehate list` - 列出豁免者
   
4. **诅咒模式切换**
   - `/abysscurse curse <abyss-curse|decompression-sickness>` - 切换诅咒模式
   
5. **调试命令**
   - `/abysscurse debug <on|off>` - 开启/关闭调试模式
   - `/abysscurse debug info [player]` - 查看调试信息
   
6. **重载命令**
   - `/abysscurse reload` - 重载配置

**设计要点**：
- 使用 Paper 的 CommandAPI 或传统 CommandExecutor
- 命令补全（TabCompleter）
- 友好的错误提示

### 2.10 EventListener (事件监听器)

**职责**：
- 监听所有相关事件
- 分发事件到对应模块

**功能**：
1. **玩家移动事件**
   - PlayerMoveEvent：检测 Y 坐标变化
   - 通知 CurseManager 更新累计上升高度
   
2. **玩家加入/退出事件**
   - PlayerJoinEvent：
     - 加载玩家数据
     - **重要**：将玩家进入游戏时的 Y 坐标存储为初始安全高度（safeHeight）
     - 初始化累计上升高度为 0
   - PlayerQuitEvent：保存玩家数据
   
3. **聊天事件**
   - AsyncPlayerChatEvent：生骸和特定层级禁用聊天
   
4. **交互事件**
   - PlayerInteractEvent：特定层级禁用右键
   
5. **死亡事件**
   - PlayerDeathEvent：清除诅咒效果

**设计要点**：
- 事件优先级：MONITOR（只读）或 NORMAL
- 异步事件使用异步处理
- 避免阻塞主线程

### 2.11 SoundManager (音效管理器)

**职责**：
- 管理音效播放
   - 诅咒触发音效
   - 随机音效播放（第三层）

**功能**：
1. **音效库**
   - 所有怪物音效
   - 所有洞穴氛围音效
   - TNT 点燃音效
   
2. **音效播放**
   - 诅咒触发：远古守卫者音效
   - 第三层：随机播放音效库中的音效

**设计要点**：
- 使用 Sound 枚举或字符串常量
- 随机选择音效
- 控制播放频率（避免过于频繁）

### 2.12 FilterManager (滤镜管理器)

**职责**：
- 管理红色滤镜效果
   - 根据累计上升高度显示滤镜

**功能**：
1. **滤镜显示**
   - **正常状态**（根据累计上升高度）：
     - 累计上升高度 0：正常（无滤镜）
     - 累计上升高度 1：轻微红色滤镜（透明度约30%）
     - 累计上升高度 2：重度红色滤镜（透明度约60%）
   - **第一层诅咒状态**：
     - 触发第一层诅咒时，强制显示累计上升高度2的滤镜（重度红色滤镜）
     - 诅咒持续期间保持重度滤镜，不受累计上升高度影响
     - 诅咒结束后恢复正常的累计上升高度滤镜
   
2. **滤镜实现方案**
   - **方案一：ActionBar + RGB 渐变色文本（推荐）**
     - 使用 ActionBar 显示全屏宽度的红色渐变文本
     - 通过 RGB 颜色代码（`§c`、`§4` 等）创建渐变效果
     - 使用重复字符（如空格或特殊字符）填满 ActionBar
     - 根据累计上升高度调整红色强度（RGB 值）
     - 定期刷新（每 5-10 tick，约 0.25-0.5 秒）以维持持续效果
     - 优点：灵活控制颜色、性能开销小、视觉效果良好
     - 缺点：需要频繁更新以维持效果
   
   - **方案二：BossBar（备选）**
     - 使用红色 BossBar 覆盖屏幕
     - 根据累计上升高度调整颜色（红色系渐变）
     - 缺点：透明度无法动态控制，只能换颜色
   
   - **方案三：Title 淡入淡出（不推荐）**
     - 缺点：无法维持持续滤镜效果

**设计要点**：
- **推荐使用 ActionBar 方案**：
  - 使用 `Component.text()` API（Paper 1.21+）创建渐变文本
  - 或使用传统 `ChatColor` + 重复字符
  - RGB 渐变：累计上升 1 使用 `§c`（浅红），累计上升 2 使用 `§4`（深红）
  - 创建全屏宽度文本：使用重复的空格或特殊 Unicode 字符（如 `█`）
  - 更新频率：每 5-10 tick（平衡视觉效果和性能）
- 滤镜强度计算：
  - 累计上升 0：不显示
  - 累计上升 1：RGB(255, 100, 100) 或 `§c`
  - 累计上升 2：RGB(200, 0, 0) 或 `§4`

### 2.13 DebugManager (调试管理器)

**职责**：
- 管理调试模式
   - 输出调试信息

**功能**：
1. **调试信息输出**
   - 当前层级
   - 累计上升高度
   - 安全高度
   - 是否在 abyss 内
   - 是否在豁免区内
   - 是否为生骸
   
2. **调试模式**
   - 玩家级别调试开关
   - 全局调试开关

**设计要点**：
- 使用 ActionBar 显示调试信息
- 每秒更新一次
- 仅对开启调试的玩家显示

## 三、技术实现细节

### 3.1 累计上升高度计算算法（优化版）

**问题分析**：
- 原方案使用 `Map<Long, Integer>` 记录每个上升事件，每秒遍历所有记录清理过期项
- 在多人同时活动时，性能开销较大（O(n) 遍历）

**优化方案：时间窗口队列**

```java
// 优化后的数据结构
class PlayerCurseData {
    // 使用队列存储时间戳，每个时间戳代表1格上升
    private final Queue<Long> riseTimestamps = new ConcurrentLinkedQueue<>();
    private double safeHeight;
    private double lastY;
    private static final long EXPIRE_TIME = 20 * 60 * 1000; // 20分钟
    
    // 添加上升记录
    public void addRise(int blocks) {
        long now = System.currentTimeMillis();
        for (int i = 0; i < blocks; i++) {
            riseTimestamps.offer(now);
        }
    }
    
    // 清理过期记录并返回当前累计上升高度
    public int getTotalRise() {
        long expireTime = System.currentTimeMillis() - EXPIRE_TIME;
        // 只清理队列头部的过期项（O(k)，k为过期项数量）
        while (!riseTimestamps.isEmpty() && riseTimestamps.peek() < expireTime) {
            riseTimestamps.poll();
        }
        return riseTimestamps.size();
    }
}

// 主循环（每20tick执行）
每20tick（1秒）执行：
  currentY = player.getLocation().getY();
  lastY = playerData.getLastY();
  
  if (currentY > lastY) {
    // 上升
    int rise = (int) Math.floor(currentY - lastY);
    playerData.addRise(rise);
  } else if (currentY < lastY) {
    // 下降：不清除累计上升，只刷新安全高度
    playerData.setSafeHeight(currentY);
  }
  
  // 获取累计上升高度（内部自动清理过期项）
  int totalRise = playerData.getTotalRise();
  
  if (totalRise >= 2) {
    // 触发诅咒
    triggerCurse(player, playerData.getSafeHeight());
    playerData.clearRiseRecords(); // 清空队列
    // 累计上升高度清零时刷新安全高度（将当前高度设为新的安全高度）
    playerData.setSafeHeight(currentY);
  }
  
  // 累计上升高度为零时，将当前高度设为新的安全高度
  if (totalRise == 0 && playerData.getSafeHeight() != currentY) {
    playerData.setSafeHeight(currentY);
  }
  
  playerData.setLastY(currentY);
```

**性能优化说明**：
- **原方案**：O(n) 遍历所有记录，n 为总记录数
- **优化方案**：O(k) 清理过期项，k 为过期项数量（通常 k << n）
- **原理**：队列按时间顺序存储，过期项集中在队列头部，只需清理头部连续过期项
- **额外优化**：使用 `ConcurrentLinkedQueue` 保证线程安全，避免锁竞争

**备选方案：时间窗口计数器（更激进优化）**

如果仍需要进一步优化，可以使用固定时间窗口：

```java
// 将20分钟分为120个窗口，每个窗口10秒
private final int[] timeWindows = new int[120]; // 环形缓冲区
private int currentWindowIndex = 0;
private long lastWindowUpdate = System.currentTimeMillis();
private static final long WINDOW_DURATION = 10 * 1000; // 10秒一个窗口

public void addRise(int blocks) {
    updateWindows(); // 更新窗口索引
    timeWindows[currentWindowIndex] += blocks;
}

private void updateWindows() {
    long now = System.currentTimeMillis();
    int windowsPassed = (int) ((now - lastWindowUpdate) / WINDOW_DURATION);
    if (windowsPassed > 0) {
        // 清空过期窗口
        for (int i = 1; i <= Math.min(windowsPassed, 120); i++) {
            timeWindows[(currentWindowIndex + i) % 120] = 0;
        }
        currentWindowIndex = (currentWindowIndex + windowsPassed) % 120;
        lastWindowUpdate = now;
    }
}

public int getTotalRise() {
    updateWindows();
    int total = 0;
    for (int count : timeWindows) {
        total += count;
    }
    return total;
}
```

**推荐**：优先使用队列方案，更精确且实现简单；时间窗口方案适合超大规模服务器。

### 3.2 区域判断和诅咒臂计算

```java
// 切比雪夫距离计算（判断是否在 abyss 内）
public boolean isInAbyss(Location loc) {
  if (mode == Mode.WORLD) {
    return loc.getWorld().getEnvironment() == World.Environment.NORMAL;
  }
  
  if (mode != Mode.ABYSS) {
    return false;
  }
  
  int chunkX = loc.getBlockX() >> 4;
  int chunkZ = loc.getBlockZ() >> 4;
  
  int centerChunkX = abyssCenter.getBlockX() >> 4;
  int centerChunkZ = abyssCenter.getBlockZ() >> 4;
  
  int dx = Math.abs(chunkX - centerChunkX);
  int dz = Math.abs(chunkZ - centerChunkZ);
  
  return Math.max(dx, dz) <= abyssRadius;
}

// 计算诅咒臂（Arm of Curse）
public int getArmOfCurse(Location loc) {
  if (mode == Mode.WORLD) {
    // world 模式下，诅咒臂始终为 0
    return 0;
  }
  
  if (mode != Mode.ABYSS) {
    return Integer.MAX_VALUE; // 不在 abyss 内
  }
  
  int chunkX = loc.getBlockX() >> 4;
  int chunkZ = loc.getBlockZ() >> 4;
  
  int centerChunkX = abyssCenter.getBlockX() >> 4;
  int centerChunkZ = abyssCenter.getBlockZ() >> 4;
  
  int dx = Math.abs(chunkX - centerChunkX);
  int dz = Math.abs(chunkZ - centerChunkZ);
  
  // 切比雪夫距离
  return Math.max(dx, dz);
}

// 计算动态诅咒持续时间
public long calculateCurseDuration(int armOfCurse, int abyssRadius) {
  if (abyssRadius <= 0) {
    // 防止除零错误
    return 600 * 20; // 默认 10 分钟（tick）
  }
  
  // 基础持续时间：10 分钟 = 600 秒 = 12000 tick
  long baseDuration = 600 * 20;
  
  // 实际持续时间 = 10分钟 * (abyss半径 - 诅咒臂) / abyss半径
  double ratio = (double)(abyssRadius - armOfCurse) / abyssRadius;
  long actualDuration = (long)(baseDuration * ratio);
  
  // 确保持续时间不为负
  return Math.max(0, actualDuration);
}
```

### 3.2.1 诅咒触发和持续时间检查

```java
// 触发诅咒时的处理
public void triggerCurse(Player player, double safeHeight) {
    PlayerCurseData data = playerDataManager.getData(player);
    Location loc = player.getLocation();
    
    // 计算诅咒臂
    int armOfCurse = regionManager.getArmOfCurse(loc);
    int abyssRadius = regionManager.getAbyssRadius();
    
    // 计算动态持续时间
    long duration = calculateCurseDuration(armOfCurse, abyssRadius);
    
    // 判断诅咒层级（根据触发诅咒时的安全高度，而不是当前高度）
    // 安全高度是玩家触发诅咒时记录的高度，用于确定应该施加哪一层的诅咒效果
    int layer = getCurseLayer(safeHeight);
    
    // 更新玩家数据
    data.setCurrentLayer(layer);
    data.setCurseStartTime(System.currentTimeMillis());
    data.setCurseDuration(duration);
    data.setCurseArm(armOfCurse);
    
    // 施加诅咒效果
    effectManager.applyCurseEffects(player, layer, duration);
    
    // 第一层特殊处理：显示重度滤镜
    if (layer == 1) {
        filterManager.setCurseFilter(player, true);
    }
    
    // 播放音效
    soundManager.playCurseSound(player);
}

// 检查诅咒是否过期（定期调用，每秒）
public void checkCurseExpiry(Player player) {
    PlayerCurseData data = playerDataManager.getData(player);
    
    if (data.getCurrentLayer() == 0) {
        return; // 无诅咒
    }
    
    long now = System.currentTimeMillis();
    long elapsed = (now - data.getCurseStartTime()) / 50; // 转换为 tick
    
    if (elapsed >= data.getCurseDuration()) {
        // 诅咒过期
        if (data.getCurrentLayer() == 6) {
            // 第六层：检查是否死亡，未死亡则转换为生骸
            if (player.isOnline() && !player.isDead()) {
                narehateManager.convertToNarehate(player);
            }
        } else if (data.getCurrentLayer() == 7) {
            // 第七层：诅咒结束后未死亡则强制击杀
            if (player.isOnline() && !player.isDead()) {
                player.setHealth(0); // 强制击杀
            }
        }
        
        // 清除诅咒效果
        effectManager.removeCurseEffects(player);
        filterManager.setCurseFilter(player, false);
        data.setCurrentLayer(0);
        data.setCurseStartTime(0);
        data.setCurseDuration(0);
    }
}

// 判断诅咒层级（根据安全高度）
// 注意：这里的 safeHeight 是触发诅咒时记录的安全高度，不是玩家的当前高度
private int getCurseLayer(double safeHeight) {
    if (safeHeight >= 85 && safeHeight < 96) return 1;
    if (safeHeight >= 75 && safeHeight < 85) return 2;
    if (safeHeight >= 40 && safeHeight < 75) return 3;
    if (safeHeight >= 0 && safeHeight < 40) return 4;
    if (safeHeight >= -8 && safeHeight < 0) return 5;
    if (safeHeight >= -28 && safeHeight < -8) return 6;
    if (safeHeight >= -64 && safeHeight < -28) return 7;
    return 0; // 不在任何层级
}
```

### 3.3 效果合并逻辑（解决覆盖问题）

**问题分析**：
在 Paper 1.21 中，`addPotionEffect(effect, true)` 强制覆盖会导致：
1. **优先级混乱**：多个模块同时施加相同效果时，后添加的会覆盖先前的
2. **短时效果失效**：短时效果（如中毒、虚弱）可能被永久效果覆盖
3. **效果丢失**：某些重要效果可能被意外覆盖

**解决方案：智能效果合并策略**

```java
// 效果来源枚举
enum EffectSource {
    CURSE,        // 诅咒效果（优先级：中）
    LAYER,        // 层级效果（优先级：高）
    NAREHATE,     // 生骸效果（优先级：最高）
    TEMPORARY     // 临时效果（优先级：低，但短时效果优先）
}

// 效果数据类
class EffectData {
    PotionEffectType type;
    int amplifier;
    int duration; // -1 表示永久
    EffectSource source;
    long timestamp; // 添加时间
}

// 效果管理器
class EffectManager {
    // 存储玩家当前所有效果及其来源
    private final Map<UUID, Map<PotionEffectType, EffectData>> playerEffects = new ConcurrentHashMap<>();
    
    // 添加效果
    public void addEffect(Player player, PotionEffectType type, int amplifier, 
                         int duration, EffectSource source) {
        UUID uuid = player.getUniqueId();
        Map<PotionEffectType, EffectData> effects = playerEffects.computeIfAbsent(
            uuid, k -> new ConcurrentHashMap<>()
        );
        
        EffectData existing = effects.get(type);
        EffectData newEffect = new EffectData(type, amplifier, duration, source, 
                                             System.currentTimeMillis());
        
        // 判断是否应该添加/覆盖
        boolean shouldApply = false;
        if (existing == null) {
            // 没有现有效果，直接添加
            shouldApply = true;
        } else {
            // 有现有效果，比较优先级和强度
            if (shouldOverride(existing, newEffect)) {
                shouldApply = true;
            }
        }
        
        if (shouldApply) {
            effects.put(type, newEffect);
            applyEffectToPlayer(player, newEffect);
        }
    }
    
    // 判断是否应该覆盖
    private boolean shouldOverride(EffectData existing, EffectData newEffect) {
        // 优先级规则
        int existingPriority = getPriority(existing.source);
        int newPriority = getPriority(newEffect.source);
        
        // 1. 优先级高的覆盖优先级低的
        if (newPriority > existingPriority) {
            return true;
        }
        
        // 2. 相同优先级时，强度高的覆盖强度低的
        if (newPriority == existingPriority) {
            if (newEffect.amplifier > existing.amplifier) {
                return true;
            }
            // 强度相同时，短时效果优先（避免永久效果覆盖短时效果）
            if (newEffect.amplifier == existing.amplifier) {
                if (existing.duration == -1 && newEffect.duration > 0) {
                    // 现有效果是永久的，新效果是短时的，不覆盖
                    return false;
                }
                if (newEffect.duration == -1 && existing.duration > 0) {
                    // 新效果是永久的，现有效果是短时的，覆盖
                    return true;
                }
            }
        }
        
        // 3. 优先级低的不能覆盖优先级高的
        return false;
    }
    
    private int getPriority(EffectSource source) {
        switch (source) {
            case NAREHATE: return 3;
            case LAYER: return 2;
            case CURSE: return 1;
            case TEMPORARY: return 0;
            default: return 0;
        }
    }
    
    // 应用效果到玩家
    private void applyEffectToPlayer(Player player, EffectData effect) {
        PotionEffect potionEffect = new PotionEffect(
            effect.type,
            effect.duration == -1 ? Integer.MAX_VALUE : effect.duration,
            effect.amplifier - 1, // 等级从0开始
            true,  // 环境粒子
            false  // 不显示图标（避免UI混乱）
        );
        
        // 关键：不使用 force=true，而是先移除再添加
        player.removePotionEffect(effect.type);
        player.addPotionEffect(potionEffect);
    }
    
    // 移除效果
    public void removeEffect(Player player, PotionEffectType type, EffectSource source) {
        UUID uuid = player.getUniqueId();
        Map<PotionEffectType, EffectData> effects = playerEffects.get(uuid);
        if (effects == null) return;
        
        EffectData existing = effects.get(type);
        if (existing != null && existing.source == source) {
            effects.remove(type);
            player.removePotionEffect(type);
            
            // 检查是否有其他来源的同类型效果需要恢复
            // （这里可以扩展，如果有多个来源的效果）
        }
    }
    
    // 刷新所有效果（定期调用，处理过期效果）
    public void refreshEffects(Player player) {
        UUID uuid = player.getUniqueId();
        Map<PotionEffectType, EffectData> effects = playerEffects.get(uuid);
        if (effects == null) return;
        
        long now = System.currentTimeMillis();
        List<PotionEffectType> toRemove = new ArrayList<>();
        
        for (Map.Entry<PotionEffectType, EffectData> entry : effects.entrySet()) {
            EffectData effect = entry.getValue();
            // 检查短时效果是否过期
            if (effect.duration > 0) {
                long elapsed = now - effect.timestamp;
                if (elapsed >= effect.duration * 50) { // duration 是 tick 数
                    toRemove.add(entry.getKey());
                } else {
                    // 重新应用效果（确保效果持续）
                    applyEffectToPlayer(player, effect);
                }
            } else {
                // 永久效果，直接重新应用
                applyEffectToPlayer(player, effect);
            }
        }
        
        // 移除过期效果
        for (PotionEffectType type : toRemove) {
            effects.remove(type);
            player.removePotionEffect(type);
        }
    }
}
```

**使用示例**：

```java
// 添加诅咒效果
effectManager.addEffect(player, PotionEffectType.NAUSEA, 0, -1, EffectSource.CURSE);

// 添加层级效果（优先级更高）
effectManager.addEffect(player, PotionEffectType.REGENERATION, 0, -1, EffectSource.LAYER);

// 添加短时效果（如中毒）
effectManager.addEffect(player, PotionEffectType.POISON, 1, 200, EffectSource.TEMPORARY);

// 定期刷新（每秒）
Bukkit.getScheduler().runTaskTimer(plugin, () -> {
    for (Player player : Bukkit.getOnlinePlayers()) {
        effectManager.refreshEffects(player);
    }
}, 0, 20);
```

**关键改进点**：
1. **不使用 `force=true`**：先 `removePotionEffect()` 再 `addPotionEffect()`
2. **优先级系统**：不同来源的效果有明确优先级
3. **智能合并**：相同类型效果根据优先级和强度决定是否覆盖
4. **短时效果保护**：永久效果不会覆盖短时效果（除非优先级更高）
5. **定期刷新**：确保效果持续，并清理过期效果
6. **状态追踪**：维护效果来源，便于管理和调试

**注意事项**：
- 定期刷新频率：建议每 20 tick（1秒）刷新一次
- 性能考虑：使用 `ConcurrentHashMap` 保证线程安全
- 效果冲突：某些效果（如生命恢复和中毒）可能需要特殊处理

### 3.4 ActionBar 红色滤镜实现

**实现方案**：使用 ActionBar 显示全屏宽度的红色渐变文本

```java
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.TextColor;
import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;

public class FilterManager {
    private static final String FULL_WIDTH_CHAR = "█"; // 或使用空格 " "
    private static final int ACTIONBAR_WIDTH = 50; // 大约50个字符宽度
    
    // 存储玩家是否处于第一层诅咒状态
    private final Map<UUID, Boolean> curseFilterState = new ConcurrentHashMap<>();
    
    // 方案一：使用 Adventure API（Paper 1.21+ 推荐）
    public void updateFilter(Player player, int totalRise) {
        UUID uuid = player.getUniqueId();
        boolean isCurseFilter = curseFilterState.getOrDefault(uuid, false);
        
        // 第一层诅咒状态：强制显示重度滤镜
        if (isCurseFilter) {
            updateFilterWithColor(player, 2); // 使用累计上升高度2的滤镜
            return;
        }
        
        // 正常状态：根据累计上升高度显示
        if (totalRise == 0) {
            // 不显示滤镜
            player.sendActionBar(Component.empty());
            return;
        }
        
        updateFilterWithColor(player, totalRise);
    }
    
    // 设置第一层诅咒滤镜状态
    public void setCurseFilter(Player player, boolean enabled) {
        UUID uuid = player.getUniqueId();
        if (enabled) {
            curseFilterState.put(uuid, true);
            updateFilterWithColor(player, 2); // 显示重度滤镜
        } else {
            curseFilterState.remove(uuid);
            // 恢复正常的累计上升高度滤镜
            int totalRise = playerDataManager.getTotalRise(player);
            updateFilter(player, totalRise);
        }
    }
    
    // 内部方法：根据强度更新滤镜
    private void updateFilterWithColor(Player player, int intensity) {
        TextColor filterColor = getFilterColor(intensity);
        
        // 创建全屏宽度的红色文本
        Component filterText = Component.text()
            .content(FULL_WIDTH_CHAR.repeat(ACTIONBAR_WIDTH))
            .color(filterColor)
            .build();
        
        player.sendActionBar(filterText);
    }
    
    private TextColor getFilterColor(int totalRise) {
        if (totalRise == 1) {
            // 轻微红色：RGB(255, 100, 100)
            return TextColor.color(255, 100, 100);
        } else if (totalRise >= 2) {
            // 重度红色：RGB(200, 0, 0)
            return TextColor.color(200, 0, 0);
        }
        return TextColor.color(0, 0, 0); // 黑色（不显示）
    }
    
    // 方案二：使用传统 ChatColor（兼容性更好）
    public void updateFilterLegacy(Player player, int totalRise) {
        if (totalRise == 0) {
            player.spigot().sendMessage(
                net.md_5.bungee.api.ChatMessageType.ACTION_BAR,
                new net.md_5.bungee.api.chat.TextComponent("")
            );
            return;
        }
        
        String colorCode;
        if (totalRise == 1) {
            colorCode = "§c"; // 浅红色
        } else {
            colorCode = "§4"; // 深红色
        }
        
        // 创建全屏宽度文本
        String filterText = colorCode + FULL_WIDTH_CHAR.repeat(ACTIONBAR_WIDTH);
        
        player.spigot().sendMessage(
            net.md_5.bungee.api.ChatMessageType.ACTION_BAR,
            net.md_5.bungee.api.chat.TextComponent.fromLegacyText(filterText)
        );
    }
    
    // 方案三：RGB 渐变效果（更精细的控制）
    public void updateFilterGradient(Player player, int totalRise) {
        if (totalRise == 0) {
            player.sendActionBar(Component.empty());
            return;
        }
        
        // 创建渐变效果：从中心向两侧渐变
        Component.Builder builder = Component.text();
        int center = ACTIONBAR_WIDTH / 2;
        
        for (int i = 0; i < ACTIONBAR_WIDTH; i++) {
            int distance = Math.abs(i - center);
            double intensity = 1.0 - (distance / (double) center);
            intensity = Math.max(0, Math.min(1, intensity));
            
            // 根据累计上升高度和位置计算颜色
            int red = (int) (255 * intensity * (totalRise == 1 ? 0.4 : 0.8));
            int green = (int) (100 * intensity * (totalRise == 1 ? 0.4 : 0.2));
            int blue = (int) (100 * intensity * (totalRise == 1 ? 0.4 : 0.2));
            
            builder.append(Component.text(FULL_WIDTH_CHAR)
                .color(TextColor.color(red, green, blue)));
        }
        
        player.sendActionBar(builder.build());
    }
}

// 定期更新（每 5-10 tick）
Bukkit.getScheduler().runTaskTimer(plugin, () -> {
    for (Player player : Bukkit.getOnlinePlayers()) {
        int totalRise = playerDataManager.getTotalRise(player);
        filterManager.updateFilter(player, totalRise);
    }
}, 0, 5); // 每 5 tick 更新一次（0.25秒）
```

**实现要点**：
1. **字符选择**：
   - `█`（全角方块）：视觉效果最好，但可能在某些字体下显示异常
   - 空格 ` `：兼容性好，但需要更多字符才能填满
   - `▬`（水平条）：中等效果
   
2. **更新频率**：
   - 建议每 5-10 tick（0.25-0.5秒）更新一次
   - 太频繁（每 tick）会影响性能
   - 太慢（每 20 tick）会导致效果不连续
   
3. **颜色强度**：
   - 累计上升 1：使用较浅的红色（RGB(255, 100, 100) 或 `§c`）
   - 累计上升 2：使用深红色（RGB(200, 0, 0) 或 `§4`）
   - 可以添加闪烁效果：在两种颜色间切换
   
4. **性能优化**：
   - 只在累计上升高度 > 0 时发送 ActionBar
   - 使用缓存避免重复创建 Component
   - 批量更新玩家（避免每 tick 遍历所有玩家）

### 3.5 数据持久化

```java
// 异步保存
Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
  File playerFile = new File(plugin.getDataFolder(), 
    "players/" + player.getUniqueId() + ".yml");
  YamlConfiguration config = YamlConfiguration.loadConfiguration(playerFile);
  
  config.set("safeHeight", playerData.getSafeHeight());
  config.set("totalRise", playerData.getTotalRise());
  config.set("currentLayer", playerData.getCurrentLayer());
  config.set("curseStartTime", playerData.getCurseStartTime());
  config.set("curseDuration", playerData.getCurseDuration());
  config.set("curseArm", playerData.getCurseArm());
  config.set("isNarehate", playerData.isNarehate());
  config.set("narehateType", playerData.getNarehateType().name());
  
  config.save(playerFile);
});
```

**注意**：累计上升记录时间（Queue<Long>）不需要持久化，因为：
- 玩家退出游戏时，累计上升高度会清零
- 重新进入游戏时，从新的安全高度开始记录

## 四、开发优先级

### 阶段一：核心框架（基础功能）
1. ConfigManager - 配置管理
2. ModeManager - 模式管理
3. RegionManager - 区域管理
4. PlayerDataManager - 玩家数据管理
5. CommandHandler - 命令处理（基础命令）

### 阶段二：诅咒系统（核心功能）
1. CurseManager - 诅咒管理器
2. AbyssCurseHandler - 深渊诅咒处理器
3. EffectManager - 效果管理器
4. EventListener - 事件监听（移动事件）

### 阶段三：完整功能（扩展功能）
1. LayerEffectApplier - 层级效果
2. NarehateManager - 生骸系统
3. AchievementManager - 成就系统
4. SoundManager - 音效管理
5. FilterManager - 滤镜管理

### 阶段四：优化和完善（收尾工作）
1. DecompressionSicknessHandler - 减压病模式
2. DebugManager - 调试系统
3. 性能优化
4. 错误处理完善
5. 测试和修复

## 五、注意事项

1. **性能优化**
   - 使用区块坐标缓存
   - 异步处理耗时操作
   - 避免频繁的数据库查询
   - 合理使用调度器（不要每tick都执行）

2. **线程安全**
   - 玩家数据使用 ConcurrentHashMap
   - 配置读取使用同步机制
   - 异步保存时注意数据一致性

3. **错误处理**
   - 配置文件损坏时的默认值
   - 玩家数据加载失败的处理
   - 命令参数验证

4. **兼容性**
   - 确保与 Paper 1.21.10 兼容
   - 测试不同版本的 Minecraft
   - 处理版本差异（如世界高度）

5. **用户体验**
   - 友好的错误提示
   - 清晰的命令帮助
   - 流畅的效果过渡
   - 合理的性能开销

## 六、开发须知

根据需求文档，开发时需要注意以下事项：

1. **异步处理**
   - 所有持久化与日志写入应放在异步任务中
   - 使用 `BukkitScheduler.runTaskAsynchronously()` 进行异步操作
   - 避免在主线程中进行文件 I/O 操作

2. **效果合并**
   - 多个状态可能同时对玩家应用不同效果
   - 需要集中统一计算最终合并，避免覆盖
   - 使用 EffectManager 统一管理所有效果

3. **占位资源**
   - 如果需要用到美术资源、但暂时缺失，请给出占位文件
   - 占位文件命名格式：`美术资源.png.txt`（或其他合适的格式）
   - 在占位文件中说明资源用途和预期效果

4. **调试模式**
   - 允许管理员打开（比如键入命令开启）开发用模式
   - 在聊天栏输出当前层、累计上升高度、安全高度，便于调试
   - 调试信息应清晰易读，便于排查问题

## 七、文件结构

```
src/main/java/io/github/kaleidscoper/abysscurse/
├── AbyssCursePlugin.java (主类)
├── config/
│   ├── ConfigManager.java
│   └── PluginConfig.java
├── mode/
│   └── ModeManager.java
├── region/
│   ├── RegionManager.java
│   ├── AbyssRegion.java
│   └── ExemptionZone.java
├── data/
│   ├── PlayerDataManager.java
│   └── PlayerCurseData.java
├── curse/
│   ├── CurseManager.java
│   ├── AbyssCurseHandler.java
│   └── DecompressionSicknessHandler.java
├── effect/
│   ├── EffectManager.java
│   ├── CurseEffectApplier.java
│   └── LayerEffectApplier.java
├── narehate/
│   └── NarehateManager.java
├── achievement/
│   └── AchievementManager.java
├── command/
│   └── CommandHandler.java
├── listener/
│   └── EventListener.java
├── sound/
│   └── SoundManager.java
├── filter/
│   └── FilterManager.java
└── debug/
    └── DebugManager.java

src/main/resources/
├── plugin.yml
├── config.yml
└── advancements/
    └── abysscurse/
        ├── root.json
        ├── red_whistle.json
        ├── blue_whistle.json
        ├── moon_whistle.json
        ├── black_whistle.json
        ├── white_whistle.json
        ├── final_dive.json
        ├── from_abyss.json
        └── netherworld_bottom.json
```

## 八、测试计划

1. **单元测试**
   - 区域判断逻辑
   - 累计上升高度计算
   - 效果合并逻辑

2. **集成测试**
   - 模式切换流程
   - 诅咒触发流程
   - 生骸转换流程

3. **性能测试**
   - 大量玩家同时在线
   - 频繁移动事件
   - 数据持久化性能

4. **兼容性测试**
   - 不同 Paper 版本
   - 不同插件组合
   - 不同服务器配置

