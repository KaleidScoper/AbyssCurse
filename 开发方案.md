# AbyssCurse 插件开发方案

## 一、项目整体架构

### 1.1 架构设计原则

- **模块化设计**：各功能模块独立，通过接口交互
- **事件驱动**：基于 Bukkit 事件系统，响应玩家行为
- **异步处理**：持久化和日志写入使用异步任务
- **状态集中管理**：统一管理玩家状态，避免效果覆盖
- **配置驱动**：支持配置文件和命令动态配置

### 1.2 整体架构图

```
AbyssCursePlugin (主类)
├── ConfigManager (配置管理)
├── ModeManager (模式管理)
├── RegionManager (区域管理)
│   ├── AbyssRegion (深渊区域)
│   └── ExemptionZone (豁免区)
├── PlayerDataManager (玩家数据管理)
│   └── PlayerCurseData (玩家诅咒数据)
├── CurseManager (诅咒管理器)
│   ├── AbyssCurseHandler (深渊诅咒处理器)
│   └── DecompressionSicknessHandler (减压病处理器)
├── EffectManager (效果管理器)
│   ├── CurseEffectApplier (诅咒效果施加器)
│   └── LayerEffectApplier (层级效果施加器)
├── NarehateManager (生骸管理器)
├── AchievementManager (成就管理器)
├── CommandHandler (命令处理器)
├── EventListener (事件监听器)
├── SoundManager (音效管理器)
├── FilterManager (滤镜管理器)
└── DebugManager (调试管理器)
```

### 1.3 数据流向

```
玩家行为事件
    ↓
EventListener (事件监听)
    ↓
PlayerDataManager (更新玩家数据)
    ↓
RegionManager (检查区域)
    ↓
CurseManager (计算诅咒)
    ↓
EffectManager (施加效果)
    ↓
PlayerDataManager (持久化数据)
```

## 二、核心模块设计

### 2.1 ConfigManager (配置管理模块)

**职责**：
- 加载和保存配置文件
- 提供配置访问接口
- 验证配置有效性

**功能**：
1. **模式配置**
   - 当前模式（off/abyss/world）
   - abyss 模式下的中心坐标和切比雪夫距离
   
2. **诅咒配置**
   - 当前诅咒模式（abyss-curse/decompression-sickness）
   - 累计上升阈值（默认2m）
   - 累计上升过期时间（默认20分钟）
   
3. **豁免配置**
   - 豁免区列表（角点坐标对）
   - 豁免者列表（玩家UUID）
   
4. **调试配置**
   - 调试模式开关

**设计要点**：
- 使用 Paper 的 Config 系统（YAML）
- 配置变更时自动重载
- 提供默认配置和配置验证

### 2.2 ModeManager (模式管理模块)

**职责**：
- 管理插件的三种模式
- 提供模式切换接口
- 验证模式切换条件

**功能**：
1. **模式状态管理**
   - 当前模式枚举（OFF, ABYSS, WORLD）
   - 模式切换逻辑
   - 模式切换时的回调通知
   
2. **模式验证**
   - abyss 模式需要有效的区域配置
   - 模式切换权限检查

**设计要点**：
- 使用枚举类型定义模式
- 模式切换时通知相关模块（RegionManager、CurseManager）
- 提供模式查询接口

### 2.3 RegionManager (区域管理模块)

**职责**：
- 管理 abyss 区域和豁免区
- 判断玩家是否在区域内
- 提供区域编辑接口

**功能**：
1. **AbyssRegion (深渊区域)**
   - 中心区块坐标（从方块坐标计算）
   - 切比雪夫距离（区块单位）
   - 判断玩家是否在 abyss 内
   - 支持 world 模式（整个主世界）
   
2. **ExemptionZone (豁免区)**
   - 存储豁免区列表（角点坐标对）
   - 判断玩家是否在豁免区内
   - 支持添加/删除豁免区
   
3. **区域查询优化**
   - 使用区块坐标缓存
   - 减少重复计算

**设计要点**：
- 使用切比雪夫距离计算（性能优化）
- 区块坐标计算：`chunkX = blockX >> 4, chunkZ = blockZ >> 4`
- 提供高效的区域判断方法（避免频繁计算）

### 2.4 PlayerDataManager (玩家数据管理模块)

**职责**：
- 管理所有玩家的诅咒相关数据
- 数据持久化
- 提供数据访问接口

**功能**：
1. **PlayerCurseData (玩家诅咒数据)**
   - 安全高度（double）
   - 累计上升高度（int，0-2）
   - 累计上升记录时间（Map<Long, Integer>，时间戳 -> 上升高度）
   - 当前诅咒层级（int，1-7）
   - 诅咒生效时间（long，时间戳）
   - 是否为生骸（boolean）
   - 生骸类型（LUCKY/SAD，枚举）
   - 调试模式开关（boolean）
   
2. **数据持久化**
   - 使用 YAML 或 JSON 存储玩家数据
   - 异步保存（避免阻塞主线程）
   - 定期自动保存
   - 玩家退出时保存
   
3. **数据访问**
   - 提供线程安全的数据访问方法
   - 支持批量更新

**设计要点**：
- 使用 ConcurrentHashMap 存储在线玩家数据
- 异步持久化（BukkitScheduler.runTaskAsynchronously）
- 数据文件结构：`players/{UUID}.yml`

### 2.5 CurseManager (诅咒管理器)

**职责**：
- 管理诅咒逻辑
- 计算诅咒触发条件
- 协调诅咒效果施加

**功能**：
1. **AbyssCurseHandler (深渊诅咒处理器)**
   - 累计上升高度计算
     - 每秒（20tick）检查玩家 Y 坐标
     - 上升时：累计上升高度 +1，记录时间戳
     - 下降时：刷新安全高度，不清除累计上升
     - 20分钟后自动过期（累计上升高度 -1）
     - 达到阈值（2m）时触发诅咒
   - 诅咒层级判断（根据安全高度）
   - 诅咒持续时间管理（10分钟）
   
2. **DecompressionSicknessHandler (减压病处理器)**
   - 根据玩家当前高度判断层级
   - 永久持续诅咒
   - 浅层（y >= 0）：第六层诅咒
   - 深层（0 > y >= -64）：无诅咒
   
3. **诅咒触发逻辑**
   - 检查玩家是否在 abyss 内
   - 检查玩家是否在豁免区
   - 检查玩家是否为生骸
   - 满足条件时触发诅咒

**设计要点**：
- 使用 BukkitScheduler 实现定时检查（每秒）
- 使用时间戳管理累计上升记录的过期
- 诅咒触发时通知 EffectManager

### 2.6 EffectManager (效果管理器)

**职责**：
- 统一管理所有效果施加
- 避免效果覆盖
- 合并多个状态的效果

**功能**：
1. **CurseEffectApplier (诅咒效果施加器)**
   - 根据诅咒层级施加对应效果
   - 管理诅咒持续时间（10分钟）
   - 效果叠加逻辑（层级越高效果越多）
   
2. **LayerEffectApplier (层级效果施加器)**
   - 根据玩家高度施加层级效果
   - 显示 Title/Subtitle
   - 施加永久效果（只要在范围内）
   - 触发成就
   
3. **效果合并逻辑**
   - 收集所有需要施加的效果
   - 合并相同类型的效果（取最大值）
   - 统一施加，避免覆盖

**设计要点**：
- 使用 Bukkit 的 PotionEffect 系统
- 定期刷新效果（每秒检查）
- 效果列表：使用 Map<PotionEffectType, Integer> 存储

### 2.7 NarehateManager (生骸管理器)

**职责**：
- 管理生骸系统
   - 生骸转换逻辑
   - 生骸效果管理
   - 生骸数据持久化

**功能**：
1. **生骸转换**
   - 第六层诅咒10分钟后未死亡自动转换
   - 随机分配生骸类型（幸运/悲惨）
   - 清除所有诅咒效果
   - 触发"来自深渊"成就
   
2. **生骸效果管理**
   - 幸运生骸：迅捷2、急迫2、力量2、跳跃提升2、夜视、生命恢复2、村庄英雄、海豚的恩惠、潮涌能量、幸运
   - 悲惨生骸：生命恢复2、抗性提升4、伤害吸收4、抗火、水下呼吸、缓降、聊天栏禁用
   - 永久效果（定期刷新）
   
3. **生骸豁免**
   - 生骸不受任何诅咒影响
   - 在 CurseManager 中检查

**设计要点**：
- 使用随机数生成器分配类型
- 效果永久持续（定期刷新）
- 聊天栏禁用：监听聊天事件并取消

### 2.8 AchievementManager (成就管理器)

**职责**：
- 管理自定义成就系统
- 触发成就
- 成就进度显示

**功能**：
1. **成就定义**
   - 使用 Paper 的 Advancement API
   - 创建独立的成就树（命名空间：abysscurse）
   - 隐藏成就（hidden: true）
   
2. **成就触发**
   - 进入对应层级时触发
   - 成为生骸时触发
   - 挑战类成就使用特殊音效
   
3. **成就列表**
   - 阿比斯之渊（根节点，默认达成）
   - 赤笛、苍笛、月笛、黑笛、白笛、绝界行、奈落之底、来自深渊

**设计要点**：
- 使用 JSON 文件定义成就（advancements/）
- 挑战类成就：`"criteria": {"trigger": "minecraft:impossible"}`
- 音效：`ui.toast.challenge_complete`

### 2.9 CommandHandler (命令处理器)

**职责**：
- 处理所有命令
- 权限检查
- 命令参数验证

**功能**：
1. **模式切换命令**
   - `/abysscurse mode <off|abyss|world> [centerX] [centerY] [centerZ] [distance]`
   - 权限：`abysscurse.admin`
   
2. **区域管理命令**
   - `/abysscurse abyss set <x> <y> <z> <distance>` - 设置 abyss 区域
   - `/abysscurse exemption add <x1> <y1> <z1> <x2> <y2> <z2>` - 添加豁免区
   - `/abysscurse exemption remove <index>` - 删除豁免区
   - `/abysscurse exemption list` - 列出豁免区
   
3. **豁免者管理命令**
   - `/abysscurse narehate add <player>` - 添加豁免者
   - `/abysscurse narehate remove <player>` - 移除豁免者
   - `/abysscurse narehate list` - 列出豁免者
   
4. **诅咒模式切换**
   - `/abysscurse curse <abyss-curse|decompression-sickness>` - 切换诅咒模式
   
5. **调试命令**
   - `/abysscurse debug <on|off>` - 开启/关闭调试模式
   - `/abysscurse debug info [player]` - 查看调试信息
   
6. **重载命令**
   - `/abysscurse reload` - 重载配置

**设计要点**：
- 使用 Paper 的 CommandAPI 或传统 CommandExecutor
- 命令补全（TabCompleter）
- 友好的错误提示

### 2.10 EventListener (事件监听器)

**职责**：
- 监听所有相关事件
- 分发事件到对应模块

**功能**：
1. **玩家移动事件**
   - PlayerMoveEvent：检测 Y 坐标变化
   - 通知 CurseManager 更新累计上升高度
   
2. **玩家加入/退出事件**
   - PlayerJoinEvent：加载玩家数据
   - PlayerQuitEvent：保存玩家数据
   
3. **聊天事件**
   - AsyncPlayerChatEvent：生骸和特定层级禁用聊天
   
4. **交互事件**
   - PlayerInteractEvent：特定层级禁用右键
   
5. **死亡事件**
   - PlayerDeathEvent：清除诅咒效果

**设计要点**：
- 事件优先级：MONITOR（只读）或 NORMAL
- 异步事件使用异步处理
- 避免阻塞主线程

### 2.11 SoundManager (音效管理器)

**职责**：
- 管理音效播放
   - 诅咒触发音效
   - 随机音效播放（第三层）

**功能**：
1. **音效库**
   - 所有怪物音效
   - 所有洞穴氛围音效
   - TNT 点燃音效
   
2. **音效播放**
   - 诅咒触发：远古守卫者音效
   - 第三层：随机播放音效库中的音效

**设计要点**：
- 使用 Sound 枚举或字符串常量
- 随机选择音效
- 控制播放频率（避免过于频繁）

### 2.12 FilterManager (滤镜管理器)

**职责**：
- 管理红色滤镜效果
   - 根据累计上升高度显示滤镜

**功能**：
1. **滤镜显示**
   - 累计上升高度 0：正常（无滤镜）
   - 累计上升高度 1：轻微红色滤镜（透明度约30%）
   - 累计上升高度 2：重度红色滤镜（透明度约60%）
   
2. **滤镜实现方案**
   - **方案一：ActionBar + RGB 渐变色文本（推荐）**
     - 使用 ActionBar 显示全屏宽度的红色渐变文本
     - 通过 RGB 颜色代码（`§c`、`§4` 等）创建渐变效果
     - 使用重复字符（如空格或特殊字符）填满 ActionBar
     - 根据累计上升高度调整红色强度（RGB 值）
     - 定期刷新（每 5-10 tick，约 0.25-0.5 秒）以维持持续效果
     - 优点：灵活控制颜色、性能开销小、视觉效果良好
     - 缺点：需要频繁更新以维持效果
   
   - **方案二：BossBar（备选）**
     - 使用红色 BossBar 覆盖屏幕
     - 根据累计上升高度调整颜色（红色系渐变）
     - 缺点：透明度无法动态控制，只能换颜色
   
   - **方案三：Title 淡入淡出（不推荐）**
     - 缺点：无法维持持续滤镜效果

**设计要点**：
- **推荐使用 ActionBar 方案**：
  - 使用 `Component.text()` API（Paper 1.21+）创建渐变文本
  - 或使用传统 `ChatColor` + 重复字符
  - RGB 渐变：累计上升 1 使用 `§c`（浅红），累计上升 2 使用 `§4`（深红）
  - 创建全屏宽度文本：使用重复的空格或特殊 Unicode 字符（如 `█`）
  - 更新频率：每 5-10 tick（平衡视觉效果和性能）
- 滤镜强度计算：
  - 累计上升 0：不显示
  - 累计上升 1：RGB(255, 100, 100) 或 `§c`
  - 累计上升 2：RGB(200, 0, 0) 或 `§4`

### 2.13 DebugManager (调试管理器)

**职责**：
- 管理调试模式
   - 输出调试信息

**功能**：
1. **调试信息输出**
   - 当前层级
   - 累计上升高度
   - 安全高度
   - 是否在 abyss 内
   - 是否在豁免区内
   - 是否为生骸
   
2. **调试模式**
   - 玩家级别调试开关
   - 全局调试开关

**设计要点**：
- 使用 ActionBar 显示调试信息
- 每秒更新一次
- 仅对开启调试的玩家显示

## 三、技术实现细节

### 3.1 累计上升高度计算算法（优化版）

**问题分析**：
- 原方案使用 `Map<Long, Integer>` 记录每个上升事件，每秒遍历所有记录清理过期项
- 在多人同时活动时，性能开销较大（O(n) 遍历）

**优化方案：时间窗口队列**

```java
// 优化后的数据结构
class PlayerCurseData {
    // 使用队列存储时间戳，每个时间戳代表1格上升
    private final Queue<Long> riseTimestamps = new ConcurrentLinkedQueue<>();
    private double safeHeight;
    private double lastY;
    private static final long EXPIRE_TIME = 20 * 60 * 1000; // 20分钟
    
    // 添加上升记录
    public void addRise(int blocks) {
        long now = System.currentTimeMillis();
        for (int i = 0; i < blocks; i++) {
            riseTimestamps.offer(now);
        }
    }
    
    // 清理过期记录并返回当前累计上升高度
    public int getTotalRise() {
        long expireTime = System.currentTimeMillis() - EXPIRE_TIME;
        // 只清理队列头部的过期项（O(k)，k为过期项数量）
        while (!riseTimestamps.isEmpty() && riseTimestamps.peek() < expireTime) {
            riseTimestamps.poll();
        }
        return riseTimestamps.size();
    }
}

// 主循环（每20tick执行）
每20tick（1秒）执行：
  currentY = player.getLocation().getY();
  lastY = playerData.getLastY();
  
  if (currentY > lastY) {
    // 上升
    int rise = (int) Math.floor(currentY - lastY);
    playerData.addRise(rise);
  } else if (currentY < lastY) {
    // 下降：不清除累计上升，只刷新安全高度
    playerData.setSafeHeight(currentY);
  }
  
  // 获取累计上升高度（内部自动清理过期项）
  int totalRise = playerData.getTotalRise();
  
  if (totalRise >= 2) {
    // 触发诅咒
    triggerCurse(player, playerData.getSafeHeight());
    playerData.clearRiseRecords(); // 清空队列
    playerData.setSafeHeight(currentY);
  }
  
  playerData.setLastY(currentY);
```

**性能优化说明**：
- **原方案**：O(n) 遍历所有记录，n 为总记录数
- **优化方案**：O(k) 清理过期项，k 为过期项数量（通常 k << n）
- **原理**：队列按时间顺序存储，过期项集中在队列头部，只需清理头部连续过期项
- **额外优化**：使用 `ConcurrentLinkedQueue` 保证线程安全，避免锁竞争

**备选方案：时间窗口计数器（更激进优化）**

如果仍需要进一步优化，可以使用固定时间窗口：

```java
// 将20分钟分为120个窗口，每个窗口10秒
private final int[] timeWindows = new int[120]; // 环形缓冲区
private int currentWindowIndex = 0;
private long lastWindowUpdate = System.currentTimeMillis();
private static final long WINDOW_DURATION = 10 * 1000; // 10秒一个窗口

public void addRise(int blocks) {
    updateWindows(); // 更新窗口索引
    timeWindows[currentWindowIndex] += blocks;
}

private void updateWindows() {
    long now = System.currentTimeMillis();
    int windowsPassed = (int) ((now - lastWindowUpdate) / WINDOW_DURATION);
    if (windowsPassed > 0) {
        // 清空过期窗口
        for (int i = 1; i <= Math.min(windowsPassed, 120); i++) {
            timeWindows[(currentWindowIndex + i) % 120] = 0;
        }
        currentWindowIndex = (currentWindowIndex + windowsPassed) % 120;
        lastWindowUpdate = now;
    }
}

public int getTotalRise() {
    updateWindows();
    int total = 0;
    for (int count : timeWindows) {
        total += count;
    }
    return total;
}
```

**推荐**：优先使用队列方案，更精确且实现简单；时间窗口方案适合超大规模服务器。

### 3.2 区域判断优化

```java
// 切比雪夫距离计算
public boolean isInAbyss(Location loc) {
  if (mode == Mode.WORLD) {
    return loc.getWorld().getEnvironment() == World.Environment.NORMAL;
  }
  
  if (mode != Mode.ABYSS) {
    return false;
  }
  
  int chunkX = loc.getBlockX() >> 4;
  int chunkZ = loc.getBlockZ() >> 4;
  
  int centerChunkX = abyssCenter.getBlockX() >> 4;
  int centerChunkZ = abyssCenter.getBlockZ() >> 4;
  
  int dx = Math.abs(chunkX - centerChunkX);
  int dz = Math.abs(chunkZ - centerChunkZ);
  
  return Math.max(dx, dz) <= abyssDistance;
}
```

### 3.3 效果合并逻辑（解决覆盖问题）

**问题分析**：
在 Paper 1.21 中，`addPotionEffect(effect, true)` 强制覆盖会导致：
1. **优先级混乱**：多个模块同时施加相同效果时，后添加的会覆盖先前的
2. **短时效果失效**：短时效果（如中毒、虚弱）可能被永久效果覆盖
3. **效果丢失**：某些重要效果可能被意外覆盖

**解决方案：智能效果合并策略**

```java
// 效果来源枚举
enum EffectSource {
    CURSE,        // 诅咒效果（优先级：中）
    LAYER,        // 层级效果（优先级：高）
    NAREHATE,     // 生骸效果（优先级：最高）
    TEMPORARY     // 临时效果（优先级：低，但短时效果优先）
}

// 效果数据类
class EffectData {
    PotionEffectType type;
    int amplifier;
    int duration; // -1 表示永久
    EffectSource source;
    long timestamp; // 添加时间
}

// 效果管理器
class EffectManager {
    // 存储玩家当前所有效果及其来源
    private final Map<UUID, Map<PotionEffectType, EffectData>> playerEffects = new ConcurrentHashMap<>();
    
    // 添加效果
    public void addEffect(Player player, PotionEffectType type, int amplifier, 
                         int duration, EffectSource source) {
        UUID uuid = player.getUniqueId();
        Map<PotionEffectType, EffectData> effects = playerEffects.computeIfAbsent(
            uuid, k -> new ConcurrentHashMap<>()
        );
        
        EffectData existing = effects.get(type);
        EffectData newEffect = new EffectData(type, amplifier, duration, source, 
                                             System.currentTimeMillis());
        
        // 判断是否应该添加/覆盖
        boolean shouldApply = false;
        if (existing == null) {
            // 没有现有效果，直接添加
            shouldApply = true;
        } else {
            // 有现有效果，比较优先级和强度
            if (shouldOverride(existing, newEffect)) {
                shouldApply = true;
            }
        }
        
        if (shouldApply) {
            effects.put(type, newEffect);
            applyEffectToPlayer(player, newEffect);
        }
    }
    
    // 判断是否应该覆盖
    private boolean shouldOverride(EffectData existing, EffectData newEffect) {
        // 优先级规则
        int existingPriority = getPriority(existing.source);
        int newPriority = getPriority(newEffect.source);
        
        // 1. 优先级高的覆盖优先级低的
        if (newPriority > existingPriority) {
            return true;
        }
        
        // 2. 相同优先级时，强度高的覆盖强度低的
        if (newPriority == existingPriority) {
            if (newEffect.amplifier > existing.amplifier) {
                return true;
            }
            // 强度相同时，短时效果优先（避免永久效果覆盖短时效果）
            if (newEffect.amplifier == existing.amplifier) {
                if (existing.duration == -1 && newEffect.duration > 0) {
                    // 现有效果是永久的，新效果是短时的，不覆盖
                    return false;
                }
                if (newEffect.duration == -1 && existing.duration > 0) {
                    // 新效果是永久的，现有效果是短时的，覆盖
                    return true;
                }
            }
        }
        
        // 3. 优先级低的不能覆盖优先级高的
        return false;
    }
    
    private int getPriority(EffectSource source) {
        switch (source) {
            case NAREHATE: return 3;
            case LAYER: return 2;
            case CURSE: return 1;
            case TEMPORARY: return 0;
            default: return 0;
        }
    }
    
    // 应用效果到玩家
    private void applyEffectToPlayer(Player player, EffectData effect) {
        PotionEffect potionEffect = new PotionEffect(
            effect.type,
            effect.duration == -1 ? Integer.MAX_VALUE : effect.duration,
            effect.amplifier - 1, // 等级从0开始
            true,  // 环境粒子
            false  // 不显示图标（避免UI混乱）
        );
        
        // 关键：不使用 force=true，而是先移除再添加
        player.removePotionEffect(effect.type);
        player.addPotionEffect(potionEffect);
    }
    
    // 移除效果
    public void removeEffect(Player player, PotionEffectType type, EffectSource source) {
        UUID uuid = player.getUniqueId();
        Map<PotionEffectType, EffectData> effects = playerEffects.get(uuid);
        if (effects == null) return;
        
        EffectData existing = effects.get(type);
        if (existing != null && existing.source == source) {
            effects.remove(type);
            player.removePotionEffect(type);
            
            // 检查是否有其他来源的同类型效果需要恢复
            // （这里可以扩展，如果有多个来源的效果）
        }
    }
    
    // 刷新所有效果（定期调用，处理过期效果）
    public void refreshEffects(Player player) {
        UUID uuid = player.getUniqueId();
        Map<PotionEffectType, EffectData> effects = playerEffects.get(uuid);
        if (effects == null) return;
        
        long now = System.currentTimeMillis();
        List<PotionEffectType> toRemove = new ArrayList<>();
        
        for (Map.Entry<PotionEffectType, EffectData> entry : effects.entrySet()) {
            EffectData effect = entry.getValue();
            // 检查短时效果是否过期
            if (effect.duration > 0) {
                long elapsed = now - effect.timestamp;
                if (elapsed >= effect.duration * 50) { // duration 是 tick 数
                    toRemove.add(entry.getKey());
                } else {
                    // 重新应用效果（确保效果持续）
                    applyEffectToPlayer(player, effect);
                }
            } else {
                // 永久效果，直接重新应用
                applyEffectToPlayer(player, effect);
            }
        }
        
        // 移除过期效果
        for (PotionEffectType type : toRemove) {
            effects.remove(type);
            player.removePotionEffect(type);
        }
    }
}
```

**使用示例**：

```java
// 添加诅咒效果
effectManager.addEffect(player, PotionEffectType.NAUSEA, 0, -1, EffectSource.CURSE);

// 添加层级效果（优先级更高）
effectManager.addEffect(player, PotionEffectType.REGENERATION, 0, -1, EffectSource.LAYER);

// 添加短时效果（如中毒）
effectManager.addEffect(player, PotionEffectType.POISON, 1, 200, EffectSource.TEMPORARY);

// 定期刷新（每秒）
Bukkit.getScheduler().runTaskTimer(plugin, () -> {
    for (Player player : Bukkit.getOnlinePlayers()) {
        effectManager.refreshEffects(player);
    }
}, 0, 20);
```

**关键改进点**：
1. **不使用 `force=true`**：先 `removePotionEffect()` 再 `addPotionEffect()`
2. **优先级系统**：不同来源的效果有明确优先级
3. **智能合并**：相同类型效果根据优先级和强度决定是否覆盖
4. **短时效果保护**：永久效果不会覆盖短时效果（除非优先级更高）
5. **定期刷新**：确保效果持续，并清理过期效果
6. **状态追踪**：维护效果来源，便于管理和调试

**注意事项**：
- 定期刷新频率：建议每 20 tick（1秒）刷新一次
- 性能考虑：使用 `ConcurrentHashMap` 保证线程安全
- 效果冲突：某些效果（如生命恢复和中毒）可能需要特殊处理

### 3.4 ActionBar 红色滤镜实现

**实现方案**：使用 ActionBar 显示全屏宽度的红色渐变文本

```java
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.TextColor;
import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;

public class FilterManager {
    private static final String FULL_WIDTH_CHAR = "█"; // 或使用空格 " "
    private static final int ACTIONBAR_WIDTH = 50; // 大约50个字符宽度
    
    // 方案一：使用 Adventure API（Paper 1.21+ 推荐）
    public void updateFilter(Player player, int totalRise) {
        if (totalRise == 0) {
            // 不显示滤镜
            player.sendActionBar(Component.empty());
            return;
        }
        
        // 根据累计上升高度计算红色强度
        TextColor filterColor = getFilterColor(totalRise);
        
        // 创建全屏宽度的红色文本
        Component filterText = Component.text()
            .content(FULL_WIDTH_CHAR.repeat(ACTIONBAR_WIDTH))
            .color(filterColor)
            .build();
        
        player.sendActionBar(filterText);
    }
    
    private TextColor getFilterColor(int totalRise) {
        if (totalRise == 1) {
            // 轻微红色：RGB(255, 100, 100)
            return TextColor.color(255, 100, 100);
        } else if (totalRise >= 2) {
            // 重度红色：RGB(200, 0, 0)
            return TextColor.color(200, 0, 0);
        }
        return TextColor.color(0, 0, 0); // 黑色（不显示）
    }
    
    // 方案二：使用传统 ChatColor（兼容性更好）
    public void updateFilterLegacy(Player player, int totalRise) {
        if (totalRise == 0) {
            player.spigot().sendMessage(
                net.md_5.bungee.api.ChatMessageType.ACTION_BAR,
                new net.md_5.bungee.api.chat.TextComponent("")
            );
            return;
        }
        
        String colorCode;
        if (totalRise == 1) {
            colorCode = "§c"; // 浅红色
        } else {
            colorCode = "§4"; // 深红色
        }
        
        // 创建全屏宽度文本
        String filterText = colorCode + FULL_WIDTH_CHAR.repeat(ACTIONBAR_WIDTH);
        
        player.spigot().sendMessage(
            net.md_5.bungee.api.ChatMessageType.ACTION_BAR,
            net.md_5.bungee.api.chat.TextComponent.fromLegacyText(filterText)
        );
    }
    
    // 方案三：RGB 渐变效果（更精细的控制）
    public void updateFilterGradient(Player player, int totalRise) {
        if (totalRise == 0) {
            player.sendActionBar(Component.empty());
            return;
        }
        
        // 创建渐变效果：从中心向两侧渐变
        Component.Builder builder = Component.text();
        int center = ACTIONBAR_WIDTH / 2;
        
        for (int i = 0; i < ACTIONBAR_WIDTH; i++) {
            int distance = Math.abs(i - center);
            double intensity = 1.0 - (distance / (double) center);
            intensity = Math.max(0, Math.min(1, intensity));
            
            // 根据累计上升高度和位置计算颜色
            int red = (int) (255 * intensity * (totalRise == 1 ? 0.4 : 0.8));
            int green = (int) (100 * intensity * (totalRise == 1 ? 0.4 : 0.2));
            int blue = (int) (100 * intensity * (totalRise == 1 ? 0.4 : 0.2));
            
            builder.append(Component.text(FULL_WIDTH_CHAR)
                .color(TextColor.color(red, green, blue)));
        }
        
        player.sendActionBar(builder.build());
    }
}

// 定期更新（每 5-10 tick）
Bukkit.getScheduler().runTaskTimer(plugin, () -> {
    for (Player player : Bukkit.getOnlinePlayers()) {
        int totalRise = playerDataManager.getTotalRise(player);
        filterManager.updateFilter(player, totalRise);
    }
}, 0, 5); // 每 5 tick 更新一次（0.25秒）
```

**实现要点**：
1. **字符选择**：
   - `█`（全角方块）：视觉效果最好，但可能在某些字体下显示异常
   - 空格 ` `：兼容性好，但需要更多字符才能填满
   - `▬`（水平条）：中等效果
   
2. **更新频率**：
   - 建议每 5-10 tick（0.25-0.5秒）更新一次
   - 太频繁（每 tick）会影响性能
   - 太慢（每 20 tick）会导致效果不连续
   
3. **颜色强度**：
   - 累计上升 1：使用较浅的红色（RGB(255, 100, 100) 或 `§c`）
   - 累计上升 2：使用深红色（RGB(200, 0, 0) 或 `§4`）
   - 可以添加闪烁效果：在两种颜色间切换
   
4. **性能优化**：
   - 只在累计上升高度 > 0 时发送 ActionBar
   - 使用缓存避免重复创建 Component
   - 批量更新玩家（避免每 tick 遍历所有玩家）

### 3.5 数据持久化

```java
// 异步保存
Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
  File playerFile = new File(plugin.getDataFolder(), 
    "players/" + player.getUniqueId() + ".yml");
  YamlConfiguration config = YamlConfiguration.loadConfiguration(playerFile);
  
  config.set("safeHeight", playerData.getSafeHeight());
  config.set("totalRise", playerData.getTotalRise());
  config.set("currentLayer", playerData.getCurrentLayer());
  config.set("isNarehate", playerData.isNarehate());
  config.set("narehateType", playerData.getNarehateType().name());
  
  config.save(playerFile);
});
```

## 四、开发优先级

### 阶段一：核心框架（基础功能）
1. ConfigManager - 配置管理
2. ModeManager - 模式管理
3. RegionManager - 区域管理
4. PlayerDataManager - 玩家数据管理
5. CommandHandler - 命令处理（基础命令）

### 阶段二：诅咒系统（核心功能）
1. CurseManager - 诅咒管理器
2. AbyssCurseHandler - 深渊诅咒处理器
3. EffectManager - 效果管理器
4. EventListener - 事件监听（移动事件）

### 阶段三：完整功能（扩展功能）
1. LayerEffectApplier - 层级效果
2. NarehateManager - 生骸系统
3. AchievementManager - 成就系统
4. SoundManager - 音效管理
5. FilterManager - 滤镜管理

### 阶段四：优化和完善（收尾工作）
1. DecompressionSicknessHandler - 减压病模式
2. DebugManager - 调试系统
3. 性能优化
4. 错误处理完善
5. 测试和修复

## 五、注意事项

1. **性能优化**
   - 使用区块坐标缓存
   - 异步处理耗时操作
   - 避免频繁的数据库查询
   - 合理使用调度器（不要每tick都执行）

2. **线程安全**
   - 玩家数据使用 ConcurrentHashMap
   - 配置读取使用同步机制
   - 异步保存时注意数据一致性

3. **错误处理**
   - 配置文件损坏时的默认值
   - 玩家数据加载失败的处理
   - 命令参数验证

4. **兼容性**
   - 确保与 Paper 1.21.10 兼容
   - 测试不同版本的 Minecraft
   - 处理版本差异（如世界高度）

5. **用户体验**
   - 友好的错误提示
   - 清晰的命令帮助
   - 流畅的效果过渡
   - 合理的性能开销

## 六、文件结构

```
src/main/java/io/github/kaleidscoper/abysscurse/
├── AbyssCursePlugin.java (主类)
├── config/
│   ├── ConfigManager.java
│   └── PluginConfig.java
├── mode/
│   └── ModeManager.java
├── region/
│   ├── RegionManager.java
│   ├── AbyssRegion.java
│   └── ExemptionZone.java
├── data/
│   ├── PlayerDataManager.java
│   └── PlayerCurseData.java
├── curse/
│   ├── CurseManager.java
│   ├── AbyssCurseHandler.java
│   └── DecompressionSicknessHandler.java
├── effect/
│   ├── EffectManager.java
│   ├── CurseEffectApplier.java
│   └── LayerEffectApplier.java
├── narehate/
│   └── NarehateManager.java
├── achievement/
│   └── AchievementManager.java
├── command/
│   └── CommandHandler.java
├── listener/
│   └── EventListener.java
├── sound/
│   └── SoundManager.java
├── filter/
│   └── FilterManager.java
└── debug/
    └── DebugManager.java

src/main/resources/
├── plugin.yml
├── config.yml
└── advancements/
    └── abysscurse/
        ├── root.json
        ├── red_whistle.json
        ├── blue_whistle.json
        ├── moon_whistle.json
        ├── black_whistle.json
        ├── white_whistle.json
        ├── final_dive.json
        ├── from_abyss.json
        └── netherworld_bottom.json
```

## 七、测试计划

1. **单元测试**
   - 区域判断逻辑
   - 累计上升高度计算
   - 效果合并逻辑

2. **集成测试**
   - 模式切换流程
   - 诅咒触发流程
   - 生骸转换流程

3. **性能测试**
   - 大量玩家同时在线
   - 频繁移动事件
   - 数据持久化性能

4. **兼容性测试**
   - 不同 Paper 版本
   - 不同插件组合
   - 不同服务器配置

